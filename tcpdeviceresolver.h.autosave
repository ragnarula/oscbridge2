#ifndef TCPDEVICERESOLVER_H
#define TCPDEVICERESOLVER_H

#include <boost/asio.hpp>
#include <boost/thread.hpp>
#include <memory>

class TcpResolveListener
{
public:
    virtual void OnTcpResolveConnect(boost::asio::ip::tcp::socket* Socket) = 0;
    virtual void OnTcpResolveError(const std::string& Message) = 0;
};

class TcpDeviceResolver : public std::enable_shared_from_this<TcpDeviceResolver>
{
public:
    TcpDeviceResolver(std::string& host,
                      unsigned int port,
                      boost::shared_mutex& Lock,
                      boost::asio::io_service& m_IOService,
                      TcpResolveListener* Listener);

    static void AsyncResolve(std::string& host,
                             unsigned int port,
                             boost::asio::io_service& m_IOService,
                             TcpResolveListener* Listener);

private:
    boost::asio::io_service& m_IOService;
    boost::asio::ip::tcp::resolver m_Resolver;
    TcpResolveListener* m_Listener;

    void Resolve(std::string& host, unsigned int port);

    void HandleResolve(const boost::system::error_code& ErrorCode,
                       boost::asio::ip::tcp::resolver::iterator Endpoints);

    void TryAndConnect(boost::asio::ip::tcp::resolver::iterator Endpoints);
};

#endif // TCPDEVICERESOLVER_H
